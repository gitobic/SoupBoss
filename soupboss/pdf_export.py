"""
PDF Export Utility for SoupBoss

This module provides functionality to export Rich tables and other terminal output
to professional-looking PDF documents that can be easily shared and viewed.
"""

import os
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional

from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import (
    SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer,
    PageBreak, KeepTogether
)
from reportlab.lib.enums import TA_LEFT, TA_CENTER, TA_RIGHT


class PDFExporter:
    """Utility class for exporting SoupBoss data to PDF documents."""
    
    def __init__(self):
        self.styles = getSampleStyleSheet()
        self._setup_custom_styles()
    
    def _setup_custom_styles(self):
        """Setup custom paragraph styles for consistent formatting."""
        # Title style
        self.styles.add(ParagraphStyle(
            name='SoupBossTitle',
            parent=self.styles['Title'],
            fontSize=24,
            spaceAfter=20,
            alignment=TA_CENTER,
            textColor=colors.HexColor('#2E86C1')
        ))
        
        # Subtitle style
        self.styles.add(ParagraphStyle(
            name='SoupBossSubtitle',
            parent=self.styles['Heading2'],
            fontSize=16,
            spaceAfter=12,
            spaceBefore=20,
            textColor=colors.HexColor('#34495E')
        ))
        
        # Footer style
        self.styles.add(ParagraphStyle(
            name='SoupBossFooter',
            parent=self.styles['Normal'],
            fontSize=8,
            alignment=TA_CENTER,
            textColor=colors.grey
        ))
    
    def _create_header(self, title: str, subtitle: Optional[str] = None) -> List:
        """Create standard header elements for SoupBoss PDFs."""
        elements = []
        
        # Main title
        title_para = Paragraph(title, self.styles['SoupBossTitle'])
        elements.append(title_para)
        
        # Subtitle if provided
        if subtitle:
            subtitle_para = Paragraph(subtitle, self.styles['SoupBossSubtitle'])
            elements.append(subtitle_para)
        
        # Generation timestamp
        timestamp = datetime.now().strftime("%B %d, %Y at %I:%M %p")
        timestamp_para = Paragraph(f"Generated on {timestamp}", self.styles['Normal'])
        elements.append(timestamp_para)
        elements.append(Spacer(1, 20))
        
        return elements
    
    def _create_footer(self) -> str:
        """Create standard footer text."""
        return "Generated by SoupBoss - Intelligent Job Matching System"
    
    def _create_table_from_data(self, headers: List[str], rows: List[List[str]], 
                               title: Optional[str] = None) -> List:
        """Create a formatted table from headers and row data."""
        elements = []
        
        if title:
            title_para = Paragraph(title, self.styles['SoupBossSubtitle'])
            elements.append(title_para)
        
        # Prepare table data
        table_data = [headers] + rows
        
        # Calculate column widths based on content and page width
        available_width = letter[0] - 2 * inch  # Page width minus margins
        num_cols = len(headers)
        col_width = available_width / num_cols
        
        # Create table
        table = Table(table_data, colWidths=[col_width] * num_cols)
        
        # Apply table styling
        table.setStyle(TableStyle([
            # Header row styling
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3498DB')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            
            # Data rows styling
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 8),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.beige, colors.white]),
            ('LEFTPADDING', (0, 0), (-1, -1), 6),
            ('RIGHTPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 3),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
        ]))
        
        elements.append(KeepTogether(table))
        elements.append(Spacer(1, 20))
        
        return elements
    
    def export_jobs_list(self, jobs_data: List[Dict], output_path: str, 
                        title: str = "Job Listings", filters: Optional[Dict] = None) -> str:
        """Export jobs list to PDF."""
        doc = SimpleDocTemplate(output_path, pagesize=letter)
        elements = []
        
        # Build subtitle with filters
        subtitle_parts = []
        if filters:
            if filters.get('company'):
                subtitle_parts.append(f"Company: {filters['company']}")
            if filters.get('source'):
                subtitle_parts.append(f"Source: {filters['source'].title()}")
            if filters.get('limit'):
                subtitle_parts.append(f"Limited to {filters['limit']} jobs")
        
        subtitle = " | ".join(subtitle_parts) if subtitle_parts else None
        
        # Add header
        elements.extend(self._create_header(title, subtitle))
        
        # Add summary
        summary_text = f"Total jobs: <b>{len(jobs_data)}</b>"
        if filters and filters.get('limit'):
            summary_text += f" (showing first {filters['limit']})"
        
        summary_para = Paragraph(summary_text, self.styles['Normal'])
        elements.append(summary_para)
        elements.append(Spacer(1, 10))
        
        # Prepare table data
        headers = ['ID', 'Company', 'Title', 'Department', 'Location', 'Source']
        rows = []
        
        for job in jobs_data:
            # Truncate long titles for better table formatting
            title = job.get('title', 'N/A')
            if len(title) > 40:
                title = title[:37] + "..."
            
            row = [
                str(job.get('id', '')),
                job.get('company_name', 'N/A'),
                title,
                job.get('department') or 'N/A',
                job.get('location') or 'N/A',
                job.get('source', 'N/A')
            ]
            rows.append(row)
        
        # Create table
        elements.extend(self._create_table_from_data(headers, rows))
        
        # Add footer
        elements.append(Spacer(1, 20))
        footer_para = Paragraph(self._create_footer(), self.styles['SoupBossFooter'])
        elements.append(footer_para)
        
        # Build PDF
        doc.build(elements)
        return output_path
    
    def export_companies_list(self, companies_data: List[Dict], output_path: str,
                            title: str = "Tracked Companies") -> str:
        """Export companies list to PDF."""
        doc = SimpleDocTemplate(output_path, pagesize=letter)
        elements = []
        
        # Add header
        elements.extend(self._create_header(title))
        
        # Add summary
        total_companies = len(companies_data)
        source_counts = {}
        for company in companies_data:
            source = company.get('source', 'unknown')
            source_counts[source] = source_counts.get(source, 0) + 1
        
        summary_text = f"Total companies: <b>{total_companies}</b><br/>"
        for source, count in sorted(source_counts.items()):
            summary_text += f"{source.title()}: {count} | "
        summary_text = summary_text.rstrip(" | ")
        
        summary_para = Paragraph(summary_text, self.styles['Normal'])
        elements.append(summary_para)
        elements.append(Spacer(1, 10))
        
        # Prepare table data
        headers = ['ID', 'Name', 'Source', 'Status', 'Created']
        rows = []
        
        for company in companies_data:
            row = [
                str(company.get('id', '')),
                company.get('name', 'N/A'),
                company.get('source', 'N/A').title(),
                company.get('status', 'N/A'),
                company.get('created_at', 'N/A')[:10] if company.get('created_at') else 'N/A'
            ]
            rows.append(row)
        
        # Create table
        elements.extend(self._create_table_from_data(headers, rows))
        
        # Add footer
        elements.append(Spacer(1, 20))
        footer_para = Paragraph(self._create_footer(), self.styles['SoupBossFooter'])
        elements.append(footer_para)
        
        # Build PDF
        doc.build(elements)
        return output_path
    
    def export_match_results(self, matches_data: List[Dict], output_path: str,
                           title: str = "Match Results", filters: Optional[Dict] = None) -> str:
        """Export match results to PDF."""
        doc = SimpleDocTemplate(output_path, pagesize=letter)
        elements = []
        
        # Build subtitle with filters
        subtitle_parts = []
        if filters:
            if filters.get('resume_name'):
                subtitle_parts.append(f"Resume: {filters['resume_name']}")
            if filters.get('min_score'):
                subtitle_parts.append(f"Min Score: {filters['min_score']}")
        
        subtitle = " | ".join(subtitle_parts) if subtitle_parts else None
        
        # Add header
        elements.extend(self._create_header(title, subtitle))
        
        # Add summary
        if matches_data:
            avg_score = sum(float(match.get('similarity_score', 0)) for match in matches_data) / len(matches_data)
            max_score = max(float(match.get('similarity_score', 0)) for match in matches_data)
            min_score = min(float(match.get('similarity_score', 0)) for match in matches_data)
            
            summary_text = f"""
            <b>Match Statistics:</b><br/>
            Total matches: {len(matches_data)}<br/>
            Average score: {avg_score:.3f}<br/>
            Highest score: {max_score:.3f}<br/>
            Lowest score: {min_score:.3f}
            """
        else:
            summary_text = "No match results to display."
        
        summary_para = Paragraph(summary_text, self.styles['Normal'])
        elements.append(summary_para)
        elements.append(Spacer(1, 10))
        
        if matches_data:
            # Prepare table data
            headers = ['Score', 'Resume', 'Job Title', 'Company', 'Department']
            rows = []
            
            for match in matches_data:
                # Format similarity score
                score = float(match.get('similarity_score', 0))
                score_str = f"{score:.3f}"
                
                # Truncate long job titles
                job_title = match.get('job_title', 'N/A')
                if len(job_title) > 35:
                    job_title = job_title[:32] + "..."
                
                row = [
                    score_str,
                    match.get('resume_name', 'N/A'),
                    job_title,
                    match.get('company_name', 'N/A'),
                    match.get('job_department') or 'N/A'
                ]
                rows.append(row)
            
            # Create table
            elements.extend(self._create_table_from_data(headers, rows))
        
        # Add footer
        elements.append(Spacer(1, 20))
        footer_para = Paragraph(self._create_footer(), self.styles['SoupBossFooter'])
        elements.append(footer_para)
        
        # Build PDF
        doc.build(elements)
        return output_path


def get_pdf_exporter() -> PDFExporter:
    """Get a PDF exporter instance."""
    return PDFExporter()


def generate_pdf_filename(base_name: str, output_dir: Optional[str] = None) -> str:
    """Generate a timestamped PDF filename."""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{base_name}_{timestamp}.pdf"
    
    if output_dir:
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        return os.path.join(output_dir, filename)
    
    return filename